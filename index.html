<!-- index.html -->
<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="manifest" href="./manifest.webmanifest">
    <title>計器レイアウト（オフライン対応）</title>
    <style>
        :root {
            --ink: #000;
            --bg: #fff;
            --sky: #8ec5ff;
            --ground: #f7b36a;
            --box-border: #8a8a8a;
            /* 数値ボックスの枠色（ややグレー） */
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--ink);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif
        }

        main {
            max-width: 420px;
            margin: 0 auto;
            padding: 10px
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-auto-rows: auto;
            gap: 12px
        }

        /* ラベルは中央揃え。外枠は付けない */
        .hLabel {
            font-weight: 800;
            letter-spacing: .02em;
            margin: 0 0 6px 0;
            text-align: center
        }

        /* 数値ボックスのみ枠あり（グレー寄り） */
        .box {
            border: 2px solid var(--box-border);
            border-radius: 10px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            font-weight: 800;
            background: #fff
        }

        .num {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
            font-size: 18px
        }

        .unit {
            font-size: 14px;
            opacity: .9
        }

        /* 人工地平：キャンバスのCSS枠のみ */
        #pfd {
            display: block;
            width: 100%;
            aspect-ratio: 1/1;
            background: #fff;
            border: 3px solid #000;
            border-radius: 8px
        }

        /* ボタン行 */
        .btns {
            display: flex;
            gap: 10px;
            justify-content: flex-start
        }

        button {
            appearance: none;
            background: #fff;
            border: 2px solid #000;
            border-radius: 8px;
            padding: 8px 16px;
            font-weight: 800
        }

        button:disabled {
            opacity: .5
        }

        .note {
            font-size: 12px;
            margin-top: 6px;
            opacity: .8
        }
    </style>
</head>

<body>
    <main>
        <div class="grid">
            <!-- 左上：人工地平 -->
            <section style="grid-column:1">
                <canvas id="pfd"></canvas>
            </section>

            <!-- 右上：ANGLE -->
            <section class="stack" style="grid-column:2">
                <h2 class="hLabel">ANGLE</h2>
                <div class="box"><span class="num" id="angPitch">—</span><span class="unit">上下 (°)</span></div>
                <div class="box"><span class="num" id="angRoll">—</span><span class="unit">左右 (°)</span></div>
            </section>

            <!-- SPD -->
            <section class="stack" style="grid-column:1">
                <h2 class="hLabel">SPD</h2>
                <div class="box"><span class="num" id="spdKts">—</span><span class="unit">knot</span></div>
                <div class="box"><span class="num" id="spdKmh">—</span><span class="unit">km/h</span></div>
            </section>

            <!-- ALT -->
            <section class="stack" style="grid-column:2">
                <h2 class="hLabel">ALT</h2>
                <div class="box"><span class="num" id="altFt">—</span><span class="unit">Feet</span></div>
                <div class="box"><span class="num" id="altM">—</span><span class="unit">m</span></div>
            </section>

            <!-- HDG -->
            <section class="stack" style="grid-column:1">
                <h2 class="hLabel">HDG</h2>
                <div class="box"><span class="num" id="hdg">—</span><span class="unit">°</span></div>
            </section>

            <!-- VSPD -->
            <section class="stack" style="grid-column:2">
                <h2 class="hLabel">VSPD</h2>
                <div class="box"><span class="num" id="vspdFts">—</span><span class="unit">Ft/s</span></div>
                <div class="box"><span class="num" id="vspdMs">—</span><span class="unit">m/s</span></div>
            </section>

            <!-- 操作 -->
            <section style="grid-column:1 / span 2">
                <div class="btns">
                    <button id="startBtn">START</button>
                    <button id="zeroBtn" disabled>ZERO</button>
                </div>
                <div class="note" id="env">HTTPS で開いてください。初回オンラインで読み込むと以後はオフライン動作します。</div>
            </section>
        </div>
    </main>

    <script>
        // ===== PWA: Service Worker 登録 =====
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').catch(console.error);
            });
        }

        // ===== ユーティリティ =====
        const $ = id => document.getElementById(id);
        const fmt = (v, d = 1) => Number.isFinite(v) ? v.toFixed(d) : '—';
        const secure = () => location.protocol === 'https:' || location.hostname === 'localhost';

        // 単位係数
        const MS_TO_KTS = 1.9438444924, MS_TO_KMH = 3.6, M_TO_FT = 3.280839895;

        // ===== 人工地平（水平線だけ） =====
        const canvas = $('pfd');
        const ctx = canvas.getContext('2d', { alpha: false });
        let beta = 0, gamma = 0, beta0 = 0, gamma0 = 0; // β=上下, γ=左右

        function resize() {
            const r = canvas.getBoundingClientRect(), dpr = window.devicePixelRatio || 1;
            canvas.width = Math.round(r.width * dpr);
            canvas.height = Math.round(r.height * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            drawPFD();
        }
        window.addEventListener('resize', resize, { passive: true });
        resize();

        function drawPFD() {
            const w = canvas.clientWidth, h = canvas.clientHeight;
            ctx.clearRect(0, 0, w, h);

            const pitchPxPerDeg = h / 120;
            const y = h / 2 + beta * pitchPxPerDeg;
            const roll = gamma * Math.PI / 180;

            ctx.save();
            ctx.translate(w / 2, y);
            ctx.rotate(roll);

            // 空
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--sky').trim();
            ctx.fillRect(-w, -h, w * 2, h);
            // 地面
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ground').trim();
            ctx.fillRect(-w, 0, w * 2, h);
            // 水平線
            ctx.fillStyle = '#000';
            ctx.fillRect(-w, -1, w * 2, 2);

            ctx.restore();
        }

        // ===== DeviceOrientation =====
        async function startOrientation() {
            if (!window.DeviceOrientationEvent) return;
            try {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    const p = await DeviceOrientationEvent.requestPermission();
                    if (p !== 'granted') return;
                }
            } catch (e) { /* iOS 以外 */ }

            window.addEventListener('deviceorientation', ev => {
                const b = ev.beta ?? 0;
                const g = ev.gamma ?? 0;
                beta = b - beta0; gamma = g - gamma0;
                $('angPitch').textContent = fmt(beta, 1);
                $('angRoll').textContent = fmt(gamma, 1);
                drawPFD();
            }, true);

            $('zeroBtn').disabled = false;
        }

        $('zeroBtn').addEventListener('click', () => {
            beta0 += beta;
            gamma0 += gamma;
        });

        // ===== Geolocation（速度・高度・昇降率・方位） =====
        let watchId = null, lastLL = null;
        let lastAlt = null, lastTime = null, emaVspd = null;
        const VSPD_ALPHA = 0.25;

        function startGeo() {
            if (!('geolocation' in navigator)) return;
            const opt = { enableHighAccuracy: true, maximumAge: 0, timeout: 15000 };
            watchId = navigator.geolocation.watchPosition(onGeo, () => { }, opt);
        }

        function onGeo(pos) {
            const c = pos.coords;

            // 速度（未提供なら前回位置から推定）
            let spd = Number.isFinite(c.speed) ? c.speed : null;
            if (spd == null && lastLL) {
                const dt = (pos.timestamp - lastLL.t) / 1000;
                if (dt > 0) {
                    const d = haversine(lastLL.lat, lastLL.lon, c.latitude, c.longitude);
                    spd = d / dt;
                }
            }
            lastLL = { lat: c.latitude, lon: c.longitude, t: pos.timestamp };

            // 高度と昇降率
            const alt = Number.isFinite(c.altitude) ? c.altitude : NaN; // m
            let vspd = NaN; // m/s
            if (Number.isFinite(alt)) {
                if (lastAlt != null && lastTime != null) {
                    const dt = (pos.timestamp - lastTime) / 1000;
                    if (dt > 0) {
                        const raw = (alt - lastAlt) / dt;
                        emaVspd = (emaVspd == null) ? raw : VSPD_ALPHA * raw + (1 - VSPD_ALPHA) * emaVspd;
                        vspd = emaVspd;
                    }
                }
                lastAlt = alt; lastTime = pos.timestamp;
            }

            // 方位
            const hdg = Number.isFinite(c.heading) ? c.heading : NaN;

            // 表示
            $('spdKts').textContent = Number.isFinite(spd) ? fmt(spd * MS_TO_KTS, 0) : '—';
            $('spdKmh').textContent = Number.isFinite(spd) ? fmt(spd * MS_TO_KMH, 0) : '—';

            $('altFt').textContent = Number.isFinite(alt) ? fmt(alt * M_TO_FT, 0) : '—';
            $('altM').textContent = Number.isFinite(alt) ? fmt(alt, 0) : '—';

            const sign = Number.isFinite(vspd) ? (vspd >= 0 ? '+' : '−') : '';
            $('vspdFts').textContent = Number.isFinite(vspd) ? `${sign}${fmt(Math.abs(vspd) * M_TO_FT, 1)}` : '—';
            $('vspdMs').textContent = Number.isFinite(vspd) ? `${sign}${fmt(Math.abs(vspd), 2)}` : '—';

            $('hdg').textContent = Number.isFinite(hdg) ? String(Math.round(hdg) % 360) : '—';
        }

        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371000, toRad = d => d * Math.PI / 180;
            const dLat = toRad(lat2 - lat1), dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
            return 2 * R * Math.asin(Math.sqrt(a));
        }

        // ===== 開始 =====
        $('startBtn').addEventListener('click', async () => {
            if (!secure()) { alert('HTTPS で開いてください（または localhost）。'); return; }
            $('startBtn').disabled = true;
            $('env').textContent = '計測中です（オフライン対応）';
            await startOrientation();
            startGeo();
        });

        if (!secure()) {
            $('env').textContent = 'HTTPS で開いてください（または localhost）';
        }
    </script>
</body>

</html>
